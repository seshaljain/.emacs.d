#+TITLE: Emacs config
#+AUTHOR: Seshal Jain
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :results silent
#+STARTUP: overview

#+BEGIN_QUOTE
I’m sure I’ll be tweaking it forever though, it’s almost as satisfying
as actually using it.
#+END_QUOTE

* Meta
When this configuration is loaded for the first time, the =init.el= is
the file that is loaded.
#+BEGIN_SRC emacs-lisp :tangle no
;; This file replaces itself with the actual configuration at first run.
;; Tangle requires org
(require 'org)
;; Open the configuration
(find-file (concat user-emacs-directory "init.org"))
;; tangle init.org
(org-babel-tangle)
;; load init.el
(load-file (concat user-emacs-directory "init.el"))
;; byte-compile init.el
(byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

Lexical scoping for the init-file is needed, it can be specified in
the header.
This is the first line of the actual configuration:
#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

Tangle and compile this file on save automatically:
#+BEGIN_SRC emacs-lisp
(defun tangle-init ()
  "If the current buffer is 'init.org' the code-blocks are
tangled, and the tangled file is compiled."
  (when (equal (buffer-file-name)
               (expand-file-name (concat user-emacs-directory "init.org")))
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil))
      (org-babel-tangle)
      (byte-compile-file (concat user-emacs-directory "init.el")))))
(add-hook 'after-save-hook 'tangle-init)
#+END_SRC

Define separate =customize= file
#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/.custom.el")
  (load custom-file t)
#+END_SRC

* Keybindings
Rebind M-x to C-x C-m
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-x\C-m" 'execute-extended-command)
#+END_SRC

* Packages
** Add package archives
#+BEGIN_SRC emacs-lisp
(require 'package)
(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
										(not (gnutls-available-p))))
			 (proto (if no-ssl "http" "https")))
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives '("gnu" . (concat proto "://elpa.gnu.org/packages/")))))

(package-initialize)
#+END_SRC

** Setup use-package
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
(setq use-package-always-ensure t)
#+END_SRC

** Package configs
*** ace-jump-mode
#+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode
  :bind ("M-s" . ace-jump-mode)
  :hook (prog-mode))
#+END_SRC

*** auto-complete
#+BEGIN_SRC emacs-lisp
(use-package auto-complete
  :config
  (ac-config-default)
  (global-auto-complete-mode t)
  (add-to-list 'ac-modes 'rjsx-mode))
#+END_SRC

*** counsel/swiper/ivy
#+BEGIN_SRC emacs-lisp
(use-package counsel
	:bind (("M-x" . counsel-M-x)
				 ("C-x C-f" . counsel-find-file)
				 ("C-x l" . counsel-locate)
				 ("C-x b" . counsel-ibuffer)
	       ("M-y" . counsel-yank-pop)))

(use-package swiper
  :diminish ivy-mode
	:config
	(ivy-mode 1)
	(setq ivy-use-virtual-buffers t)
	(setq enable-recursive-minibuffers t)
  (setq ivy-count-format "[%d/%d] ")
	:bind (("C-s" . swiper)
	       :map ivy-minibuffer-map ("M-y" . ivy-next-line)))
#+END_SRC

*** diminish
#+BEGIN_SRC emacs-lisp
(use-package diminish)
#+END_SRC

*** expand-region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind ("M-=" . er/expand-region))
#+END_SRC

*** iedit
#+BEGIN_SRC emacs-lisp
(use-package iedit)
#+END_SRC

*** js2
Taken from [[https://github.com/anschwa/emacs.d][https://github.com/anschwa/emacs.d]]
Use js2-mode in =<script>= tags
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :defer t
  :interpreter "node"
  :config
  (setq js2-basic-offset 2
        js2-highlight-level 3
        js2-mode-show-parse-errors nil
        js2-mode-show-strict-warnings nil)
  (setq js2-global-externs '("JSON"
                             "jest"
                             "describe"
                             "it"
                             "expect"
                             "beforeEach"
                             "beforeAll"
                             "afterEach"
                             "afterAll"
                             "process"
                             "module"
                             "require"))
  (defun my/js-mode-hook ()
    (set (make-local-variable 'compile-command)
         (format "node %s" (file-name-nondirectory buffer-file-name))))

  (defun my/js2-mode-on-region (start end)
    "Narrow on the active region, then turn on js2-mode."
    (interactive "r")
    (deactivate-mark)
    (narrow-to-region start end)
    (js2-mode))

  (defun my/narrow-to-javascript ()
    "Automatically narrow between <script> tags, then turn on js2-mode."
    (interactive)
    (let ((start-tag-name "<script")
          (end-tag-name   "</script")
          (start          nil)
          (end            nil))
      ;; Find start tag. Search backwards first to give priority to tag pairs
      ;; the cursor is currently inside.
      (setq start (search-backward start-tag-name nil t))
      (when (null start)
        ;; if start tag not found backwards, then try forwards.
        (setq start (search-forward start-tag-name nil t)))
      (catch 'missing-script-start-tag
        (when (null start)
          (throw 'missing-script-start-tag "start tag not found")))
      ;; start is found, move cursor down a line, start highlighting
      (forward-line)
      (move-beginning-of-line nil)
      (set-mark-command nil) ;(evil-visual-line)
      ;; jump to end tag. always search forward
      (setq end (search-forward end-tag-name nil t))
      (catch 'missing-script-end-tag
        (when (null end)
          (deactivate-mark)
          (throw 'missing-script-end-tag "end tag not found")))
      ;; end tag is found. now move cursor up one line
      (forward-line -1)
      (move-end-of-line nil)
      ;; turn on js2-mode for this region. (and narrow)
      (call-interactively #'my/js2-mode-on-region)))

  (defun my/widen-from-javascript ()
    "Undo the effects of `my/narrow-to-javascript'."
    (interactive)
    (widen)
    (web-mode))

  :bind (:map js2-mode-map
              ("C-c j w" . my/widen-from-javascript))
  :hook ((js-mode . my/js-mode-hook)))

(use-package web-mode
  :bind (:map web-mode-map
              ("C-c j n" . my/narrow-to-javascript)))
#+END_SRC

**** rjsx
#+BEGIN_SRC emacs-lisp
(use-package rjsx-mode
  :defer t
  :mode ("\\.js\\'"))
#+END_SRC

*** magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :defer t)
#+END_SRC

*** markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :defer t
  :init (setq markdown-command "multimarkdown")
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.mdx?$\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode)))
#+END_SRC

*** prettier
Dependency: prettier
#+BEGIN_SRC sh :tangle no
npm i -g prettier
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package prettier
  :defer t)
#+END_SRC

*** rainbow
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :defer t)
#+END_SRC

*** try
#+BEGIN_SRC emacs-lisp
(use-package try
  :defer t)
#+END_SRC

*** web
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer t
	:mode ("\\.html\\'")
	:config
	(add-to-list 'web-mode-comment-formats '("javascript" . "//"))
	(setq web-mode-markup-indent-offset 2)
	(setq web-mode-css-indent-offset 2)
	(setq web-mode-code-indent-offset 2)
	(setq web-mode-style-padding 0)
	(setq web-mode-script-padding 0))
#+END_SRC

**** emmet
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :defer t
  :diminish
  :config
  (setq emmet-indentation 2)
  (defadvice emmet-preview-accept (after expand-and-fontify activate)
    "Update the font-face after an emmet expantion."
    (font-lock-flush))
  :hook (web-mode css-mode))
#+END_SRC

*** which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer t
  :diminish which-key-mode
	:config
	(which-key-mode))
#+END_SRC

*** windmove
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :bind
  (("C-c w f"  . 'windmove-right)
   ("C-c w b"  . 'windmove-left)
   ("C-c w n"  . 'windmove-down)
   ("C-c w p"  . 'windmove-up)))
#+END_SRC

*** yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
	:config (yas-global-mode 1))

(use-package yasnippet-snippets)
#+END_SRC

* Utility Functions
** Reload config
#+BEGIN_SRC emacs-lisp
(defun my/reload-config()
	"Reload init.el"
	(interactive)
  (load-file "~/.emacs.d/init.el"))
#+END_SRC

** Kill other buffers
Kill all buffers other than the current one, without messing with the
special ones
[[https://emacsredux.com/blog/2013/03/30/kill-other-buffers/][https://emacsredux.com/blog/2013/03/30/kill-other-buffers/]]
#+BEGIN_SRC emacs-lisp
(defun my/kill-other-buffers ()
	"Kill all buffers except the active buffer"
	(interactive)
	(dolist (buffer (buffer-list))
		(unless (or (eql buffer (current-buffer)) (not (buffer-file-name buffer)))
			(kill-buffer buffer))))
#+END_SRC

** Kill All buffers
#+BEGIN_SRC emacs-lisp
(defun my/kill-all-buffers ()
  "Kill all buffers without regard for their origin."
  (interactive)
  (mapc 'kill-buffer (buffer-list)))

(global-set-key (kbd "C-M-s-k") 'my/kill-all-buffers)
#+END_SRC

** Kill dired buffers
#+BEGIN_SRC emacs-lisp
(defun my/kill-dired-buffers ()
  "Kill all dired buffers."
  (interactive)
  (mapc (lambda (buffer)
          (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
            (kill-buffer buffer)))
        (buffer-list)))
#+END_SRC

** Actually kill-word
#+BEGIN_SRC emacs-lisp
(defun my/kill-inner-word ()
  "Kills the entire word under cursor."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))

(global-set-key (kbd "C-c w k") 'my/kill-inner-word)
#+END_SRC

** Sudo save
If the current buffer is not writable, ask if it should be saved with
=sudo=.

Happily taken from Pascals configuration:
https://github.com/SirPscl/emacs.d#sudo-save

#+BEGIN_SRC emacs-lisp
(defun my/sudo-file-name (filename)
  "Prepend '/sudo:root@`system-name`:' to FILENAME if appropriate.
This is, when it doesn't already have a sudo-prefix."
  (if (not (or (string-prefix-p "/sudo:root@localhost:"
																filename)
							 (string-prefix-p (format "/sudo:root@%s:" (system-name))
																filename)))
			(format "/sudo:root@%s:%s" (system-name) filename)
    filename))

(defun my/sudo-save-buffer ()
  "Save FILENAME with sudo if the user approves."
  (interactive)
  (when buffer-file-name
    (let ((file (my/sudo-file-name buffer-file-name)))
			(if (yes-or-no-p (format "Save file as %s? " file))
					(write-file file)))))

(advice-add 'save-buffer :around
						'(lambda (fn &rest args)
							 (when (or (not (buffer-file-name))
												 (not (buffer-modified-p))
												 (file-writable-p (buffer-file-name))
												 (not (my/sudo-save-buffer)))
								 (call-interactively fn args))))
#+END_SRC

** Open non-text files in Native appliations
http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html
#+BEGIN_SRC emacs-lisp
(defun my/xdg-open (&optional @fname)
  "Open the current file or dired marked files in external app."
  (interactive)
  (let* (($file-list
					(if @fname (progn (list @fname))
						(if (string-equal major-mode "dired-mode")
								(dired-get-marked-files)
							(list (buffer-file-name)))))
				 ($do-it-p (if (<= (length $file-list) 5)
											 t (y-or-n-p "Open more than 5 files? "))))
    (when $do-it-p
			(cond ((string-equal system-type "darwin")
						 (mapc
							(lambda ($fpath)
								(shell-command
								 (concat "open "
												 (shell-quote-argument $fpath))))  $file-list))
						((string-equal system-type "gnu/linux")
						 (mapc
							(lambda ($fpath) (let ((process-connection-type nil))
																 (start-process "" nil "xdg-open" $fpath))) $file-list))))))
#+END_SRC

* Modes
** org
 Don't ask before executing a code block
 #+BEGIN_SRC emacs-lisp
 (setq org-confirm-babel-evaluate nil)
 #+END_SRC

 Don't indent code blocks
 #+BEGIN_SRC emacs-lisp
 (setq org-edit-src-content-indentation 0)
 #+END_SRC

*** Org Capture
 #+BEGIN_SRC emacs-lisp
 (custom-set-variables
	'(org-directory "~/Dropbox/org")
	'(org-startup-folded 'overview))

 (global-set-key (kbd "C-c c") 'org-capture)

 (setq org-capture-templates
       '(("t" "TIL" entry (file+headline "~/Dropbox/org/til.org" "TIL")
					"* %^{TIL} %^g\n%^{Description}\n%T" :prepend t)
				 ("l" "Link" entry (file+headline "~/Dropbox/org/links.org" "Links")
					"* %? %^L %^g\n%T" :prepend t)
         ("k" "Keybinding" entry (file "~/Dropbox/org/learn-keybindings.org")
					"* =%^{Keybinding}= %^g\n%^{Description}")))

 (defadvice org-capture-finalize
		 (after delete-capture-frame activate)
	 "Advise capture-finalize to close the frame"
   (if (equal "capture" (frame-parameter nil 'name))
       (delete-frame)))

 (defadvice org-capture-destroy
     (after delete-capture-frame activate)
   "Advise capture-destroy to close the frame"
   (if (equal "capture" (frame-parameter nil 'name))
       (delete-frame)))
 #+END_SRC

*** Org Structure Templates
 Modify =<s= to insert "emacs-lisp" by default
 [[https://nicholasvanhorn.com/posts/org-structure-completion.html][https://nicholasvanhorn.com/posts/org-structure-completion.html]]
 #+BEGIN_SRC emacs-lisp
 (eval-after-load 'org
   '(progn (add-to-list 'org-structure-template-alist
												'("s" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" ""))))
 #+END_SRC

** dired

Ability to use =a= to visit a new directory or file in =dired= instead
of using =RET=. =RET= works just fine, but it will create a new buffer
for /every/ interaction whereas =a= reuses the current buffer.

#+BEGIN_SRC emacs-lisp
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

Human readable units
#+BEGIN_SRC emacs-lisp
(setq-default dired-listing-switches "-alh")
#+END_SRC

Open in new frame
#+BEGIN_SRC emacs-lisp
(defun my/dired-find-file-other-frame ()
  "In Dired, visit this file or directory in another window."
  (interactive)
  (find-file-other-frame (dired-get-file-for-visit)))

(eval-after-load "dired"
  '(define-key dired-mode-map (kbd "C-c C-o") 'my/dired-find-file-other-frame))
#+END_SRC

* Preferences
** UX
*** Get environment variables from shell
Set $MANPATH, $PATH and exec-path from shell even when started from
GUI helpers like =dmenu= or =Spotlight=
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'exec-path-from-shell)
	(package-refresh-contents)
	(package-install 'exec-path-from-shell))

;; Safeguard, so this only runs on Linux (or MacOS)
(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))
#+END_SRC

*** Increase GC Threshold
Allow 20MB (instead of 0.76MB) before calling GC
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 20000000)
#+END_SRC

*** Ask =y/n= instead of =yes/no=
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Auto revert files on change
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC

*** Shell
**** Use bash by default
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

*** Open last buffer on split
Split functions which open the previous buffer in the new window
instead of showing the current buffer twice.
[[https://alandmoore.com/blog/2013/05/01/better-window-splitting-in-emacs/][https://alandmoore.com/blog/2013/05/01/better-window-splitting-in-emacs/]]

#+BEGIN_SRC emacs-lisp
(defun my/vsplit-last-buffer ()
	"Split frame vertically and open previous buffer in other window"
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer))

(defun my/hsplit-last-buffer ()
	"Split frame horizontally and open previous buffer in other
window"
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer))
#+END_SRC

A function to open the previous buffer in a new frame.
#+BEGIN_SRC emacs-lisp
(defun my/open-last-buffer ()
	"Open previous buffer in new frame"
  (interactive)
  (switch-to-buffer-other-frame (other-buffer)))
#+END_SRC

Change default split keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x 2") 'my/vsplit-last-buffer)
(global-set-key (kbd "C-x 3") 'my/hsplit-last-buffer)
#+END_SRC

** UI
*** Encoding
utf-8 encoding for all files, resolves =\u...= in terminal
#+BEGIN_SRC emacs-lisp
(prefer-coding-system       'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC

*** Startup
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
(setq inhibit-startup-message t)
(setq initial-major-mode 'org-mode)
(setq initial-scratch-message "<s")
#+END_SRC

*** Theme
Dracula
#+BEGIN_SRC emacs-lisp :tangle:no
(use-package dracula-theme
	:config (load-theme 'dracula))
#+END_SRC

*** Font
Victor Mono, Inter
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(font . "Victor Mono 14"))
(set-face-font 'variable-pitch "Inter")
#+END_SRC

*** Scrolling
Nicer scrolling behaviour [[https://zeekat.nl/articles/making-emacs-work-for-me.html][https://zeekat.nl/articles/making-emacs-work-for-me.html]]
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 10
scroll-step 1
scroll-conservatively 100
scroll-preserve-screen-position 1)

(setq mouse-wheel-follow-mouse 't)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
#+END_SRC

*** UI Elements
#+BEGIN_SRC emacs-lisp
(scroll-bar-mode -1)
;; (menu-bar-mode -1)
(tool-bar-mode -1)
#+END_SRC

**** Show keystrokes immediately in the =echo= area
#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.1)
#+END_SRC
** Text Editing

*** Always highlight parentheses
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC

*** Autocomplete brackets
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
#+END_SRC

*** Autosave in =/tmp=
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)

(setq backup-directory-alist
			`((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
			`((".*" ,temporary-file-directory t)))
#+END_SRC

*** Single space after sentences
#+BEGIN_SRC
(setq sentence-end-double-space nil)
#+END_SRC

*** Enable narrow-to-region
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

*** Indentation
Set tab width to 2 spaces
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2
							intent-tabs-mode nil)

;;(setq js-indent-level 2)

;;(setq python-indent 2)

;;(setq css-indent-offset 2)

;;(setq web-mode-markup-indent-offset 2)
#+END_SRC

*** Add a newline at end of file
#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

*** Delete trailing whitespace on save
#+BEGIN_SRC emacs-lisp
(add-hook 'write-file-hooks 'delete-trailing-whitespace)
#+END_SRC
