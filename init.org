#+TITLE: Emacs config
#+AUTHOR: Seshal Jain
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :results silent
#+STARTUP: overview

#+BEGIN_QUOTE
I’m sure I’ll be tweaking it forever though, it’s almost as satisfying
as actually using it.
#+END_QUOTE

* Meta
When this configuration is loaded for the first time, the =init.el= is
the file that is loaded.
#+BEGIN_SRC emacs-lisp :tangle no
;; This file replaces itself with the actual configuration at first run.
;; Tangle requires org
(require 'org)
;; Open the configuration
(find-file (concat user-emacs-directory "init.org"))
;; tangle init.org
(org-babel-tangle)
;; load init.el
(load-file (concat user-emacs-directory "init.el"))
;; byte-compile init.el
(byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

Lexical scoping for the init-file is needed, it can be specified in
the header.
This is the first line of the actual configuration:
#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

Tangle and compile this file on save automatically:
#+BEGIN_SRC emacs-lisp
(defun tangle-init ()
  "If the current buffer is 'init.org' the code-blocks are
tangled, and the tangled file is compiled."
  (when (equal (buffer-file-name)
               (expand-file-name (concat user-emacs-directory "init.org")))
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil))
      (org-babel-tangle)
      (byte-compile-file (concat user-emacs-directory "init.el")))))
(add-hook 'after-save-hook 'tangle-init)
#+END_SRC

Define separate =customize= file
#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/.custom.el")
  (load custom-file t)
#+END_SRC

* Packages
** Add package archives
#+BEGIN_SRC emacs-lisp
(require 'package)
(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives '("gnu" . (concat proto "://elpa.gnu.org/packages/")))))

(package-initialize)
#+END_SRC

** Setup use-package
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
(setq use-package-always-ensure t)
#+END_SRC

** Package configs
*** ace-jump-mode
#+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode
  :bind ("M-s" . ace-jump-mode)
  :hook (prog-mode))
#+END_SRC

*** auto-complete
#+BEGIN_SRC emacs-lisp
(use-package auto-complete
  :config
  (ac-config-default)
  (global-auto-complete-mode t)
  (add-to-list 'ac-modes 'rjsx-mode))
#+END_SRC

*** counsel/swiper/ivy
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind (("M-x" . counsel-M-x)
         ("C-x C-f" . counsel-find-file)
         ("C-x l" . counsel-locate)
         ("C-x b" . counsel-ibuffer)
         ("M-y" . counsel-yank-pop)))

(use-package swiper
  :diminish ivy-mode
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq enable-recursive-minibuffers t)
  (setq ivy-count-format "[%d/%d] ")
  :bind (("C-s" . swiper)
         :map ivy-minibuffer-map ("M-y" . ivy-next-line)))
#+END_SRC

*** diminish
#+BEGIN_SRC emacs-lisp
(use-package diminish)
#+END_SRC

*** expand-region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind ("M-=" . er/expand-region))
#+END_SRC

*** iedit
#+BEGIN_SRC emacs-lisp
(use-package iedit)
#+END_SRC

*** js2
Taken from [[https://github.com/anschwa/emacs.d][https://github.com/anschwa/emacs.d]]
Use js2-mode in =<script>= tags
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :defer t
  :interpreter "node"
  :config
  (setq js2-basic-offset 2
        js2-highlight-level 3
        js2-mode-show-parse-errors nil
        js2-mode-show-strict-warnings nil)
  (setq js2-global-externs '("JSON"
                             "jest"
                             "describe"
                             "it"
                             "expect"
                             "beforeEach"
                             "beforeAll"
                             "afterEach"
                             "afterAll"
                             "process"
                             "module"
                             "require"))
  (defun my/js-mode-hook ()
    (set (make-local-variable 'compile-command)
         (format "node %s" (file-name-nondirectory buffer-file-name))))

  (defun my/js2-mode-on-region (start end)
    "Narrow on the active region, then turn on js2-mode."
    (interactive "r")
    (deactivate-mark)
    (narrow-to-region start end)
    (js2-mode))

  (defun my/narrow-to-javascript ()
    "Automatically narrow between <script> tags, then turn on js2-mode."
    (interactive)
    (let ((start-tag-name "<script")
          (end-tag-name   "</script")
          (start          nil)
          (end            nil))
      ;; Find start tag. Search backwards first to give priority to tag pairs
      ;; the cursor is currently inside.
      (setq start (search-backward start-tag-name nil t))
      (when (null start)
        ;; if start tag not found backwards, then try forwards.
        (setq start (search-forward start-tag-name nil t)))
      (catch 'missing-script-start-tag
        (when (null start)
          (throw 'missing-script-start-tag "start tag not found")))
      ;; start is found, move cursor down a line, start highlighting
      (forward-line)
      (move-beginning-of-line nil)
      (set-mark-command nil) ;(evil-visual-line)
      ;; jump to end tag. always search forward
      (setq end (search-forward end-tag-name nil t))
      (catch 'missing-script-end-tag
        (when (null end)
          (deactivate-mark)
          (throw 'missing-script-end-tag "end tag not found")))
      ;; end tag is found. now move cursor up one line
      (forward-line -1)
      (move-end-of-line nil)
      ;; turn on js2-mode for this region. (and narrow)
      (call-interactively #'my/js2-mode-on-region)))

  (defun my/widen-from-javascript ()
    "Undo the effects of `my/narrow-to-javascript'."
    (interactive)
    (widen)
    (web-mode))

  :bind (:map js2-mode-map
              ("C-c j w" . my/widen-from-javascript))
  :hook ((js-mode . my/js-mode-hook)))

(use-package web-mode
  :bind (:map web-mode-map
              ("C-c j n" . my/narrow-to-javascript)))
#+END_SRC

**** rjsx
#+BEGIN_SRC emacs-lisp
(use-package rjsx-mode
  :defer t
  :mode ("\\.js\\'")
  :config
  (define-key rjsx-mode-map (kbd "C-c d") 'rjsx-delete-creates-full-tag)
  (define-key rjsx-mode-map (kbd "C-d") nil))
#+END_SRC

*** lorem-ipsum
#+BEGIN_SRC emacs-lisp
(use-package lorem-ipsum
  :defer t)
#+END_SRC

*** magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :defer t)
#+END_SRC

*** markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :defer t
  :init (setq markdown-command "multimarkdown")
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.mdx?$\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode)))
#+END_SRC

*** mode-line-bell
#+BEGIN_SRC emacs-lisp
(use-package mode-line-bell
  :config
  (mode-line-bell-mode))
#+END_SRC
*** prettier
Dependency: prettier
#+BEGIN_SRC sh :tangle no
npm i -g prettier
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package prettier
  :defer t)
#+END_SRC

*** rainbow
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :defer t)
#+END_SRC

*** try
#+BEGIN_SRC emacs-lisp
(use-package try
  :defer t)
#+END_SRC

*** web
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer t
  :mode ("\\.html\\'")
  :config
  (add-to-list 'web-mode-comment-formats '("javascript" . "//"))
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-style-padding 0)
  (setq web-mode-script-padding 0))
#+END_SRC

**** emmet
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :defer t
  :diminish
  :config
  (setq emmet-indentation 2)
  (defadvice emmet-preview-accept (after expand-and-fontify activate)
    "Update the font-face after an emmet expantion."
    (font-lock-flush))
  :hook (web-mode css-mode))
#+END_SRC

*** which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer t
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC

*** windmove
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :bind
  (("C-c w f"  . 'windmove-right)
   ("C-c w b"  . 'windmove-left)
   ("C-c w n"  . 'windmove-down)
   ("C-c w p"  . 'windmove-up)))
#+END_SRC

*** yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :config (yas-global-mode 1))

(use-package yasnippet-snippets)
#+END_SRC

* Utility Functions
** Reload config
#+BEGIN_SRC emacs-lisp
(defun my/reload-config()
  "Reload init.el"
  (interactive)
  (load-file "~/.emacs.d/init.el"))
#+END_SRC

** Kill other buffers
Kill all buffers other than the current one, without messing with the
special ones
[[https://emacsredux.com/blog/2013/03/30/kill-other-buffers/][https://emacsredux.com/blog/2013/03/30/kill-other-buffers/]]
#+BEGIN_SRC emacs-lisp
(defun my/kill-other-buffers ()
  "Kill all buffers except the active buffer"
  (interactive)
  (dolist (buffer (buffer-list))
    (unless (or (eql buffer (current-buffer)) (not (buffer-file-name buffer)))
      (kill-buffer buffer))))
#+END_SRC

** Kill All buffers
#+BEGIN_SRC emacs-lisp
(defun my/kill-all-buffers ()
  "Kill all buffers without regard for their origin."
  (interactive)
  (mapc 'kill-buffer (buffer-list)))

(global-set-key (kbd "C-M-s-k") 'my/kill-all-buffers)
#+END_SRC

** Kill dired buffers
#+BEGIN_SRC emacs-lisp
(defun my/kill-dired-buffers ()
  "Kill all dired buffers."
  (interactive)
  (mapc (lambda (buffer)
          (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
            (kill-buffer buffer)))
        (buffer-list)))
#+END_SRC

** Move lines up or down
#+BEGIN_SRC emacs-lisp
(defun my/move-line-up ()
  "Move line up."
  (interactive)
  (transpose-lines 1)
  (forward-line -2))

(defun my/move-line-down ()
  "Move line down."
  (interactive)
  (forward-line 1)
  (transpose-lines 1)
  (forward-line -1))
#+END_SRC

** Create new scratch buffer
#+BEGIN_SRC emacs-lisp
(defun my/create-scratch-buffer nil
  "Create a new scratch buffer <*scratchN*>."
  (interactive)
  (let ((n 0) bufname)
    (while (progn
             (setq bufname (concat "*scratch-"
                                   (if (= n 0) "" (int-to-string n)) "*"))
             (setq n (1+ n))
             (get-buffer bufname)))
    (switch-to-buffer (get-buffer-create bufname))
    (org-mode)))
#+END_SRC

** Actually kill-word
#+BEGIN_SRC emacs-lisp
(defun my/kill-inner-word ()
  "Kills the entire word under cursor."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))

(global-set-key (kbd "C-c k w") 'my/kill-inner-word)
#+END_SRC

** Kill Region / Line
- =C-w= kills the current line
- =M-w= copies the current line

If there is an active region, =C-w= and =M-w= work as default
#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single
line instead."
  (interactive
   (if mark-active
       (list (region-beginning) (region-end))
     (list (line-beginning-position) (line-beginning-position 2)))))

(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single
line instead."
  (interactive
   (if mark-active
       (list (region-beginning) (region-end))
     (message "Copied line")
     (list (line-beginning-position) (line-beginning-position 2)))))
#+END_SRC

** Rename Buffer & File
#+BEGIN_SRC emacs-lisp
(defun my/rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))
#+END_SRC

** Toggle Quotes
#+BEGIN_SRC emacs-lisp
(defun my/get-quote-chars ()
  "Get available string symbols from the active syntax-table"
  (let ((quotes '(?\' ?\" ?\`)))
    (seq-filter (lambda (q) (eq (char-syntax q) 34)) quotes)))

(defun my/toggle-quotes ()
  "Toggles a string between quote levels in most programming modes"
  (interactive)
  (let* ((beg (nth 8 (syntax-ppss)))
         (orig-quote (char-after beg))
         (quotes (my/get-quote-chars))
         (new-quote (case (length quotes)
                      (1 (when (eq orig-quote (car quotes))
                           (car quotes)))
                      (2 (cond
                          ((eq orig-quote (nth 0 quotes)) (nth 1 quotes))
                          ((eq orig-quote (nth 1 quotes)) (nth 0 quotes))))
                      (3 (cond
                          ((eq orig-quote (nth 0 quotes)) (nth 1 quotes))
                          ((eq orig-quote (nth 1 quotes)) (nth 2 quotes))
                          ((eq orig-quote (nth 2 quotes)) (nth 0 quotes)))))))
    (save-restriction
      (widen)
      (save-excursion
        (catch 'done
          (unless new-quote
            (message "Not inside a string")
            (throw 'done nil))
          (goto-char beg)
          (delete-char 1)
          (insert-char new-quote)
          (while t
            (cond ((eobp)
                   (throw 'done nil))
                  ((= (char-after) orig-quote)
                   (delete-char 1)
                   (insert-char new-quote)
                   (throw 'done nil))
                  ((= (char-after) ?\\)
                   (forward-char 1)
                   (when (= (char-after) orig-quote)
                     (delete-char -1))
                   (forward-char 1))
                  ((= (char-after) new-quote)
                   (insert-char ?\\)
                   (forward-char 1))
                  (t (forward-char 1)))))))))

(bind-key "C-c q '" 'my/toggle-quotes)
#+END_SRC

** Open non-text files in Native appliations
http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html
#+BEGIN_SRC emacs-lisp
(defun my/xdg-open (&optional @fname)
  "Open the current file or dired marked files in external app."
  (interactive)
  (let* (($file-list
          (if @fname (progn (list @fname))
            (if (string-equal major-mode "dired-mode")
                (dired-get-marked-files)
              (list (buffer-file-name)))))
         ($do-it-p (if (<= (length $file-list) 5)
                       t (y-or-n-p "Open more than 5 files? "))))
    (when $do-it-p
      (cond ((string-equal system-type "darwin")
             (mapc
              (lambda ($fpath)
                (shell-command
                 (concat "open "
                         (shell-quote-argument $fpath))))  $file-list))
            ((string-equal system-type "gnu/linux")
             (mapc
              (lambda ($fpath) (let ((process-connection-type nil))
                                 (start-process "" nil "xdg-open" $fpath))) $file-list))))))
#+END_SRC

** C++ compile without Makefile
#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook
  (lambda ()
    (unless (file-exists-p "Makefile")
      (set (make-local-variable 'compile-command)
       (let ((file (file-name-nondirectory buffer-file-name)))
         (concat "g++ -g -O2 -Wall -std=c++14 -o "
             (file-name-sans-extension file)
             " " file))))))
#+END_SRC

** Save and compile
#+BEGIN_SRC emacs-lisp
(setq compilation-ask-about-save nil)

(defun my/save-all-and-compile ()
  (interactive)
  (save-some-buffers 1)
  (compile compile-command))

(global-set-key (kbd "<f5>") 'my/save-all-and-compile)
#+END_SRC

* Modes
** org
Don't ask before executing a code block
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC

Don't indent code blocks
#+BEGIN_SRC emacs-lisp
(setq org-edit-src-content-indentation 0)
#+END_SRC

*** Org Capture
#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(org-directory "~/Dropbox/org")
 '(org-startup-folded 'overview))

(global-set-key (kbd "C-c c") 'org-capture)

(setq org-capture-templates
      '(("t" "TIL" entry (file+headline "~/Dropbox/org/til.org" "TIL")
         "* %^{TIL} %^g\n%^{Description}\n%T" :prepend t)
        ("l" "Link" entry (file+headline "~/Dropbox/org/links.org" "Links")
         "* %? %^L %^g\n%T" :prepend t)
        ("k" "Keybinding" entry (file "~/Dropbox/org/learn-keybindings.org")
         "* =%^{Keybinding}= %^g\n%^{Description}")))

(defadvice org-capture-finalize
    (after delete-capture-frame activate)
  "Advise capture-finalize to close the frame"
  (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))

(defadvice org-capture-destroy
    (after delete-capture-frame activate)
  "Advise capture-destroy to close the frame"
  (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))
#+END_SRC

*** ~Org Structure Templates~
Modify =<s= to insert "emacs-lisp" by default
[[https://nicholasvanhorn.com/posts/org-structure-completion.html][https://nicholasvanhorn.com/posts/org-structure-completion.html]]
#+BEGIN_SRC emacs-lisp :tangle no
;; (eval-after-load 'org
;;   '(progn (add-to-list 'org-structure-template-alist
;;                        '("s" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" ""))))
#+END_SRC

*** Org Latex Export
Use syntax highlighting via Minted

#+BEGIN_SRC sh :tangle no
pip install Pygments

tlmgr install minted
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-latex-listings 'minted
      org-latex-packages-alist '(("" "minted"))
      org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

Break long lines
#+BEGIN_SRC emacs-lisp
(setq org-latex-minted-options '(("breaklines" "true")
                                 ("breakanywhere" "true")))
#+END_SRC

** dired
Ability to use =a= to visit a new directory or file in =dired= instead
of using =RET=. =RET= works just fine, but it will create a new buffer
for /every/ interaction whereas =a= reuses the current buffer.
#+BEGIN_SRC emacs-lisp
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

Human readable units
#+BEGIN_SRC emacs-lisp
(setq-default dired-listing-switches "-alh")
#+END_SRC

Open in new frame
#+BEGIN_SRC emacs-lisp
(defun my/dired-find-file-other-frame ()
  "In Dired, visit this file or directory in another window."
  (interactive)
  (find-file-other-frame (dired-get-file-for-visit)))

(eval-after-load "dired"
  '(define-key dired-mode-map (kbd "C-c C-o") 'my/dired-find-file-other-frame))
#+END_SRC

* Preferences
** UX
*** Get environment variables from shell
Set $MANPATH, $PATH and exec-path from shell even when started from
GUI helpers like =dmenu= or =Spotlight=
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'exec-path-from-shell)
  (package-refresh-contents)
  (package-install 'exec-path-from-shell))

;; Safeguard, so this only runs on Linux (or MacOS)
(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))
#+END_SRC

*** Increase GC Threshold
Allow 20MB (instead of 0.76MB) before calling GC
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 20000000)
#+END_SRC

*** Ask =y/n= instead of =yes/no=
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Auto revert files on change
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC

*** Shell
**** Use bash by default
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

*** Open last buffer on split
Split functions which open the previous buffer in the new window
instead of showing the current buffer twice.
[[https://alandmoore.com/blog/2013/05/01/better-window-splitting-in-emacs/][https://alandmoore.com/blog/2013/05/01/better-window-splitting-in-emacs/]]

#+BEGIN_SRC emacs-lisp
(defun my/vsplit-last-buffer ()
  "Split frame vertically and open previous buffer in other window"
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer))

(defun my/hsplit-last-buffer ()
  "Split frame horizontally and open previous buffer in other
window"
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer))
#+END_SRC

A function to open the previous buffer in a new frame.
#+BEGIN_SRC emacs-lisp
(defun my/open-last-buffer ()
  "Open previous buffer in new frame"
  (interactive)
  (switch-to-buffer-other-frame (other-buffer)))
#+END_SRC

Change default split keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x 2") 'my/vsplit-last-buffer)
(global-set-key (kbd "C-x 3") 'my/hsplit-last-buffer)
#+END_SRC

*** Use ibuffer as default buffer list
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)

(setq ibuffer-saved-filter-groups
      '(("files"
               ("dired" (mode . dired-mode))
               ("org" (name . "^.*org$"))

               ("web" (or (mode . web-mode)
                          (mode . css-mode)))
               ("js" (mode . rjsx-mode))
               ("shell" (or (mode . eshell-mode)
                            (mode . shell-mode)))
               ("programming" (mode . python-mode))
               ("emacs" (or
                         (name . "^\\*scratch\\*$")
                         (name . "^\\*Compile-Log\\*$")
                         (name . "^\\*Messages\\*$"))))))

(add-hook 'ibuffer-mode-hook
          (lambda ()
            (ibuffer-auto-mode 1)
            (ibuffer-switch-to-saved-filter-groups "files")))

(setq ibuffer-show-empty-filter-groups nil)

(setq ibuffer-expert t)
#+END_SRC

** UI
*** Encoding
utf-8 encoding for all files, resolves =\u...= in terminal
#+BEGIN_SRC emacs-lisp
(prefer-coding-system       'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC

*** Startup
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
(setq inhibit-startup-message t)
(setq initial-major-mode 'org-mode)
(setq initial-scratch-message nil)
#+END_SRC

*** Theme
Dracula
#+BEGIN_SRC emacs-lisp :tangle:no
(use-package dracula-theme
  :config (load-theme 'dracula))
#+END_SRC

*** Font
Victor Mono, Inter
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(font . "Victor Mono 14"))
(set-face-font 'variable-pitch "Inter")
#+END_SRC

*** Scrolling
Nicer scrolling behaviour [[https://zeekat.nl/articles/making-emacs-work-for-me.html][https://zeekat.nl/articles/making-emacs-work-for-me.html]]
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 10
scroll-step 1
scroll-conservatively 100
scroll-preserve-screen-position 1)

(setq mouse-wheel-follow-mouse 't)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
#+END_SRC

*** UI Elements
**** Disable scrollbars and toolbar
#+BEGIN_SRC emacs-lisp
(scroll-bar-mode -1)
(tool-bar-mode -1)
#+END_SRC

**** Show keystrokes immediately in the =echo= area
#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.1)
#+END_SRC

**** Thin cursor
#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC

**** Always show line and col num in modeline
#+BEGIN_SRC emacs-lisp
(setq line-number-mode t)
(setq column-number-mode t)
#+END_SRC

** Text Editing
*** Always highlight parentheses
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC

*** Autocomplete brackets
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
#+END_SRC

*** Configure file saves
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
(setq auto-save-default nil)
(setq create-lockfiles nil)

(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+END_SRC

*** Single space after sentences
#+BEGIN_SRC
(setq sentence-end-double-space nil)
#+END_SRC

*** Enable narrow-to-region
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

*** Indentation
Set tab width to 2 spaces
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2
              indent-tabs-mode nil)
#+END_SRC

*** Add a newline at end of file
#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

*** Delete trailing whitespace on save
#+BEGIN_SRC emacs-lisp
(add-hook 'write-file-hooks 'delete-trailing-whitespace)
#+END_SRC

*** Replace highlighted text
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

* Keybindings
Rebind M-x to C-x C-m
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-x\C-m" 'execute-extended-command)
#+END_SRC
